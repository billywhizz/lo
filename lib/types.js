import { list_children, is_file, is_dir, mkdir_all_safe } from "lib/fs.js"
const { core, assert } = lo;
const { write_file, read_file, mkdir, S_IRWXU, S_IRWXG, S_IROTH } = core

export async function add_app_type_deps(project_config_path = '', writer = new CopyFromRuntimeOrLoHome()){
  assert(is_file(project_config_path), `invalid config path: ${project_config_path}`)
  const lib_dir_name = 'lib'
  !is_dir(lib_dir_name) && assert(mkdir(lib_dir_name, S_IRWXU | S_IRWXG | S_IROTH) == 0,
    `could not make directory ${lib_dir_name}: errno ${lo.errno}`)

  const omit_unrelated_files = (s = '') => s && /(api\.js|d.ts)$/.test(s);
  const copy_from_runtime_or_lo_home = writer.copy.bind(writer)
  /**@param items {string[] | undefined} */
  const copy_items = (items) => items?.filter(omit_unrelated_files)
    .forEach(copy_from_runtime_or_lo_home)

  /**@type {{ embeds?: string[]; libs?: string[]; bindings?: (string|Record<string, unknown>)[] }} */
  const app_runtime_config = (await import(project_config_path)).default
  copy_items(app_runtime_config?.embeds)
  copy_items(app_runtime_config?.libs)
  copy_items(app_runtime_config?.bindings
    ?.map((s) => `${lib_dir_name}/${typeof s == 'string' ? s : Object.getOwnPropertyNames(s)[0]}/api.js`)
  )


  add_lo_globalsdts(writer)
  add_lib_apisalldts(lib_dir_name);
  add_lib_globalsdts(lib_dir_name, writer)

  assert(writer.errors.length == 0,
    writer.errors
      .map((s) => `failed to find "${s}" in project directory, embedded data, $LO_HOME`)
      .join('\n')
  )
}

export function add_lib_apisalldts (lib_dir = 'lib') {
  // TODO: change text and replace everything below this line
  const auogenerated_warning_line = '/* AUTOGENERATED! DO NOT EDIT THIS FILE! */'
  const apis = [{ module_name: '' }]
  apis.length = 0

  for (let i = 0, paths = list_children(lib_dir); i < paths.length; i++){
    const path = paths[i]
    if (/\.[jt]s/.test(path) || !is_file(`${path}/api.js`)) continue

    const module_name = path.replace(lib_dir +'/', '')
    apis.push({ module_name })
  }

  // console.log(apis.length)
  // console.log(apis.map((v) => v.module_name).join('\n'))
  const encoder = new TextEncoder()
  const apis_all_dts = apis
    .map((v) => `export const ${v.module_name}: typeof import('lib/${v.module_name}/api.js')`)
    .join('\n')

  // lib/apis.all.d.ts
  const lib_apis_all_dts_path = `${lib_dir}/apis.all.d.ts`
  const apis_all_dts_str = `${auogenerated_warning_line}
/// <reference no-default-lib="true"/>
${apis_all_dts}`

  if (is_file(lib_apis_all_dts_path)
    && new TextDecoder().decode(read_file(lib_apis_all_dts_path)) == apis_all_dts_str
  ) return

  write_file(
    lib_apis_all_dts_path,
    encoder.encode(apis_all_dts_str)
  )
}

export function add_lib_globalsdts (lib_dir = 'lib', writer = new CopyFromRuntimeOrLoHome()) {
  const globalsdts = `${lib_dir}/globals.d.ts`;
  !writer.errors.includes(globalsdts) && !writer.written.includes(globalsdts)
    && writer.copy(globalsdts)
  if (writer.errors.includes(globalsdts))
    write_file(globalsdts, writer.encoder.encode(lib_globalsdts_str()))
}

export function add_lo_globalsdts(writer = new CopyFromRuntimeOrLoHome()){
  const decoder = new TextDecoder()
  const delimiter = '// ####### !!!DO NOT EDIT CODE BELOW THIS LINE! AUTOGENERATED!!! #######'
  const globalsdts = 'globals.d.ts'
  const missing_globals = ['WebAssembly'].join('\n    // ')
  const omit_globals = global_this_base_omit_type().split('=')[1]
    .replace(/[ \n';]+/gm, '').split('|')
  const global_this_base_pick = `"${Object.getOwnPropertyNames(globalThis)
    .filter((s) => !missing_globals.includes(s) && !omit_globals.includes(s))
    .join(`"\n    | "`)}"`
  const autogenerated_str = `${delimiter}
// TODO: add lo.core.engine prop to determine engine
interface CurrentRuntimeGenerics extends RuntimeGenerics<'v8', '${lo.core.os}', '${lo.core.arch}'> {}
// global base type
// keep only things that we have, no need to confuse people
interface GlobalThisBase
  extends Omit<Pick<
    typeof globalThis,
    // list from: lo eval 'console.log(\`"\${Object.getOwnPropertyNames(globalThis).join(\`"    \\n| "\`)}"\`)'
    | ${global_this_base_pick}
    // missing typedefs (extract from typescript DOM lib, we don't need DOM messing with types):
    // WebAssembly issue - https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/826
    // ${missing_globals}
  >,
  GlobalThisBaseOmit
  > {}
`
  let globalsdts_str = ''
  let hasError = writer.errors.includes(globalsdts);
  !hasError && !writer.written.includes(globalsdts)
    && writer.copy(globalsdts)

  // add `true || ` to skip builtins
  hasError = writer.errors.includes(globalsdts)
  if (hasError) globalsdts_str = lo_globalsdts_str()
  else globalsdts_str = decoder.decode(read_file(globalsdts)).split(delimiter)[0]

  Object.getOwnPropertyNames(lo).forEach((s) =>
      globalsdts_str.indexOf(`  ${s}`) == -1
        && console.log(`missing Runtime['${s}'] type definition`
  ))

  // already written and no changes needed
  if (!hasError && globalsdts_str.indexOf(autogenerated_str) != -1) return;

  write_file(globalsdts, writer.encoder.encode(`${globalsdts_str}\n${autogenerated_str}`))
}

const lo_globalsdts_str = () => `
${wrap_typedef_block('lo_base_types', lo_base_types)}
${wrap_typedef_block('declared_global_types', declared_global_types)}
${wrap_typedef_block('global_this_type', global_this_type)}
${wrap_typedef_block('global_this_base_omit_type', global_this_base_omit_type)}
${wrap_typedef_block('native_lib_core_type', native_lib_core_type)}
${wrap_typedef_block('runtime_type', runtime_type)}
${wrap_typedef_block('text_encoder_types', text_encoder_types)}
${wrap_typedef_block('text_decoder_types', text_decoder_types)}
${wrap_typedef_block('iterator_types', iterator_types)}
${wrap_typedef_block('native_lib_exports_types', native_lib_exports_types)}`

const lib_globalsdts_str = () => `${wrap_typedef_block('native_lib_api_types', native_lib_api_types)}`
const wrap_typedef_block = (name, fn) => `// ####### ${name} start #######
// please add final edits to ${name} in lib/types.js
${fn()}
// ####### ${name} end #######
`;

class CopyFromRuntimeOrLoHome {
  lo_home = '';
  builtins = [''];
  errors = [''];
  written = [''];
  encoder;
  constructor(encoder = new TextEncoder()){
    this.lo_home = lo.getenv('LO_HOME');
    this.builtins = lo.builtins();
    this.errors = [];
    this.written = [];
    this.encoder = encoder
  }
  copy(s = ''){
    if (this.written.includes(s)) return;
    if (is_file(`./${s}`)) return (this.written.push(s), void 0)

    const lo_home_lib_path = `${this.lo_home}/${s}`;
    let buf = null;
    if (this.builtins.includes(s)) buf = this.encoder.encode(lo.builtin(s))
      else if (is_file(lo_home_lib_path)) buf = read_file(lo_home_lib_path)

    if(buf == null) { this.errors.push(s) }
    else {
      const dir = /\//.test(s) ? s.replace(/\/[^\/]*$/, '') : '';
      (!dir || is_dir(dir) || !Boolean(mkdir_all_safe(dir, S_IRWXU | S_IRWXG | S_IROTH)))
        && write_file(s, buf) == 0 && (this.written.push(s))
    }
  }
}

const lo_base_types = () => `/// <reference no-default-lib="true"/>
/// <reference lib="es2023"/>
// TODO: refine generic NativeLib* types for lib/<module>/api.js (platform)

// generic typedef helper for classes:
// interface IClassX { ... }
// declare var ClassX: Constructor<IClassX>
// TODO: find solution to class declaration issues (TS class declaration !== JS class declaration)
interface Constructor<T> {
  readonly prototype: T;
  new (): T;
}

type OnUnhandledRejection = (error: Error) => void;

type Require = <T extends Record<string | number | symbol, unknown>>(
  file_path: string
) => T | undefined;

interface Console {
  log: (str: unknown) => number;
  error: (str: unknown) => number;
}

// available globally with v8 --expose-gc flag
type GC = undefined | (() => void);

type ZeroOrMinusOne = 0 | -1;
type ENGINE = 'v8';
type OS = 'mac' | 'win' | 'linux';
type ARCH = 'x64' | 'arm64';
type TypedArray =
  | Uint8Array
  | Int8Array
  | Uint16Array
  | Int16Array
  | Uint32Array
  | Int32Array
  | Float32Array
  | Float64Array
  | BigUint64Array
  | BigInt64Array
  | ArrayBuffer;

type Ptr<T extends TypedArray> = T & {
  ptr: number;
  size: number;
};

type UnknownLib<T extends string | number> = Record<
  T | string | number | symbol,
  unknown
>;
type Library<T extends string | number> =
  (T extends NativeLibsKeys ? NativeLibXExport<T> : UnknownLib<T>)
    & {
      handle?: number;
      fileName?: string;
      internal?: boolean;
    };

interface RuntimeVersion {
  lo: string;
  v8: string;
}

interface RuntimeGenerics<E extends ENGINE, O extends OS, A extends ARCH> {
  engine: E;
  os: O;
  arch: A;
}
`

const text_encoder_types = () => `type TextEncoderConstructor = Constructor<ITextEncoder>;
interface ITextEncoder {
  /**
   * The encoding supported by the \`TextEncoder\` instance. Always set to \`'utf-8'\`.
   */
  readonly encoding: string;
  /**
   * UTF-8 encodes the \`input\` string and returns a \`Uint8Array\` containing the
   * encoded bytes.
   * @param [input='an empty string'] The text to encode.
   */
  encode(input?: string): Uint8Array;
  /**
   * UTF-8 encodes the \`src\` string to the \`dest\` Uint8Array and returns an object
   * containing the read Unicode code units and written UTF-8 bytes.
   *
   * \`\`\`js
   * const encoder = new TextEncoder();
   * const src = 'this is some data';
   * const dest = new Uint8Array(10);
   * const { read, written } = encoder.encodeInto(src, dest);
   * \`\`\`
   * @param src The text to encode.
   * @param dest The array to hold the encode result.
   */
  encodeInto(src?: string, dest?: Uint8Array): number;
}
`

const text_decoder_types = () => `type TextDecoderConstructor = Constructor<ITextDecoder>;
interface ITextDecoder {
  /**
   * The encoding supported by the \`TextEncoder\` instance. Always set to \`'utf-8'\`.
   */
  readonly encoding: string;
  /**
   * UTF-8 decodes the \`Uint8Array\` and returns an \`input\` string.
   */
  decode(ptr_source?: Ptr<Uint8Array> | Uint8Array): string;
}`

const iterator_types = () => `// Iterator class type from https://github.com/zloirock/core-js#iterator-helpers
interface IteratorConstructor extends Constructor<IIterator> {
  from(iterable: Iterable<any> | Iterator<any>): Iterator<any>;
}
type Uint = number;
interface IIterator {
  drop(limit: Uint): Iterator<any>;
  every(callbackfn: (value: any, counter: Uint) => boolean): boolean;
  filter(callbackfn: (value: any, counter: Uint) => boolean): Iterator<any>;
  find(callbackfn: (value: any, counter: Uint) => boolean): any;
  flatMap(callbackfn: (value: any, counter: Uint) => Iterable<any> | Iterator<any>): Iterator<any>;
  forEach(callbackfn: (value: any, counter: Uint) => void): void;
  map(callbackfn: (value: any, counter: Uint) => any): Iterator<any>;
  reduce(callbackfn: (memo: any, value: any, counter: Uint) => any, initialValue: any): any;
  some(callbackfn: (value: any, counter: Uint) => boolean): boolean;
  take(limit: Uint): Iterator<any>;
  toArray(): Array<any>;
}`

const declared_global_types = () => `declare var global: GlobalThis;
declare var onUnhandledRejection: OnUnhandledRejection;
declare var require: Require;
declare var TextEncoder: TextEncoderConstructor;
declare var TextDecoder: TextDecoderConstructor;
declare var lo: Runtime;
declare var gc: GC;
declare var Iterator: IteratorConstructor;
declare var console: Console;`

const global_this_base_omit_type = () => `// we define those manually:
type GlobalThisBaseOmit = ${declared_global_types()
  .replace(/^.+ var ([A-z]+): ([A-z]+;).*/gm, "--'$1'")
  .split('--')
  .join('  | ')
};
`
const global_this_type = () => `interface GlobalThis extends GlobalThisBase {
${declared_global_types()
    .replace(/^.+ var ([A-z]+): ([A-z]+;)/gm, "  $1:$2--")
    .split('--')
    .join('')
  }
}
`

const native_lib_core_type = () => `// lo.core = lo.load('core') + overrides listed here
type Core<T extends 'core' = 'core'> = Overwrite<NativeLibXExport<T>[T], {
  dlsym(handle: number, name: string): number;
  dlopen(path: string, flags: number): number;
  // strnlen(str: string | number, size: number): number;
  /**
   * Reads a file from the given path into a Uint8Array and returns it.
   * @param [path] The path to the file.
   */
  read_file(path: string): Uint8Array;
  /**
   * Creates/Overwrites a file at the specified path with the given Uint8Array
   * as the contents of the file.
   * @param {string}[path] The path of the file to create.
   * @param {TypedArray}[buffer] The data write to the file.
   * @returns {number} Number of bytes written
   */
  write_file(
    path: string,
    buffer: Uint8Array,
    flags?: number,
    mode?: number
  ): number;
  os: OS;
  arch: ARCH;
  engine: ENGINE;
  little_endian: boolean;
  homedir: string;
  defaultWriteFlags: number;
  defaultWriteMode: number;
  mmap(
    ptr: number,
    length: number,
    prot: number,
    flags: number,
    fd: number,
    offset: number,
    buf: Uint32Array
  ): void;
  getcwd(ptr: number, num: number, buf: Uint32Array): void;
  getenv(name: string, buf: Uint32Array): void;
  write_string(num: number, str: string): number;
  readFile(path: string, flags?: number, size?: number): Uint8Array;
  writeFile(
    path: string,
    u8: Uint8Array,
    flags?: number,
    mode?: number
  ): number;

  isFile(path: string): boolean;
  // conditionally defined props
  loader?: (specifier: string, resource: string) => string;
  sync_loader?: (specifier: string, resource: string) => string;
  binding_loader?: <T extends string>(name: T) => Library<T>;
}>;`

const runtime_type = () => `// TODO: autogenerate
interface Runtime {
  // validate with list from: lo eval 'console.log(\`"\${Object.getOwnPropertyNames(lo).join(\`":unknown;"\`)}":unknown;\`)'
  moduleCache: Map<string, ReturnType<Runtime['loadModule']>>;
  libCache: Map<string, object>;
  requireCache: Map<string, object>;
  start: number;
  errno: number;
  colors: Record<Uppercase<string>, string>;
  core: Core;
  libraries(): string[];
  builtins(): string[];
  assert(expression: any, message?: string | Function): any;
  cstr(str: string): Ptr<Uint8Array>;
  load<T extends NativeLibsKeys>(name: T): NativeLibXExport<T>;
  library<T extends string | number>(name: T): Library<T>;
  /**
   * Prints a string to the console
   * @param [str='a string'] The text to print.
   */
  print(str: string): void;
  exit(status: number): void;
  runMicroTasks(): void;
  hrtime(): number;
  nextTick(callback: Function): void;
  getAddress(buf: TypedArray): number;
  utf8Length(str: string): number;
  utf8EncodeInto(str: string, buf: TypedArray): number;
  utf8EncodeIntoAtOffset(str: string, buf: TypedArray, off: number): number;
  utf8_decode(address: number, len?: number): string;
  latin1Decode(address: number, len?: number): string;
  utf8Encode(str: string): Uint8Array;
  utf8Decode: Runtime['utf8_decode'];
  wrap<
    Handle extends Uint32Array,
    WrappedFnArgs extends unknown[],
    WrappedFnRet,
    State,
  >(
    handle: Handle,
    fn: ((...args: [...WrappedFnArgs]) => WrappedFnRet) & { state?: State },
    plen: number
  ): ((...args: WrappedFnArgs) => number) & { state?: State };
  addr(handle: TypedArray): number;
  version: RuntimeVersion;
  args: string[];
  argv: number;
  argc: number;
  workerSource: string;
  builtin(path: string): string;
  os(): OS;
  arch(): ARCH;
  getenv(str: string): string;
  evaluateModule<T extends object>(identifier: number): Promise<T>;
  loadModule(
    source: string,
    specifier: string
  ): {
    requests: string;
    isSourceTextModule: boolean;
    status: number;
    specifier: string;
    src: string;
    identity: number;
    scriptId: number;
    // js land extensions on returned value
    resource?: string;
    evaluated?: boolean;
    namespace?: object; // module namespace object
  };
  readMemory(dest: TypedArray, start: number, len: number): void;
  wrapMemory(start: number, size: number, free?: number): ArrayBuffer;
  unwrapMemory(buffer: ArrayBuffer): void;
  ptr<T extends TypedArray>(u8: T): Ptr<T>;
  register_callback(ptr: number, fn: Function): void;
  registerCallback: Runtime['register_callback'];
  setModuleCallbacks(
    on_module_load: Function,
    on_module_instantiate: Function
  ): void;

  utf8EncodeIntoPtr(str: string, ptr: number): number;
  runScript(source: string, path: string /* resource name */): void;
  pumpMessageLoop(): void;
  readMemoryAtOffset(
    u8: TypedArray,
    start: number,
    size: number,
    offset: number
  ): void;
  setFlags(str: string): void;
  getMeta: unknown;

  setenv: Core['setenv'];
  getcwd(): string;
  run_script: Runtime['runScript'];
  bindings: Runtime['libraries'];
  evaluate_module: Runtime['evaluateModule'];
  get_address: Runtime['getAddress'];
  get_meta: Runtime['getMeta'];
  latin1_decode: Runtime['latin1Decode'];
  lib_cache: Runtime['libCache'];
  load_module: Runtime['loadModule'];
  module_cache: Runtime['moduleCache'];
  next_tick: Runtime['nextTick'];
  pump_message_loop: Runtime['pumpMessageLoop'];
  read_memory: Runtime['readMemory'];
  read_memory_at_offset: Runtime['readMemoryAtOffset'];
  require_cache: Runtime['requireCache'];
  run_microtasks: Runtime['runMicroTasks'];
  set_flags: Runtime['setFlags'];
  set_module_callbacks: Runtime['setModuleCallbacks'];
  unwrap_memory: Runtime['unwrapMemory'];
  utf8_encode: Runtime['utf8Encode'];
  utf8_encode_into: Runtime['utf8EncodeInto'];
  utf8_encode_into_ptr: Runtime['utf8EncodeIntoPtr'];
  utf8_encode_into_at_offset: Runtime['utf8EncodeIntoAtOffset'];
  utf8_length: Runtime['utf8Length'];
  wrap_memory: Runtime['wrapMemory'];
}`

const native_lib_exports_types = () => `// ############ NativeLib Exports stuff ##############
// helpers
type Overwrite<T, U> = Omit<T, keyof U> & U;
type Conditional<
  Type,
  Key extends keyof Type | string | number | symbol,
  FallbackType = never
> = Key extends keyof Type
  ? Type[Key]
  : FallbackType;
type ReadonlyArrayUnknown = ReadonlyArray<unknown>;

// native libs
type NativeLibs = Awaited<typeof import("lib/apis.all.d.ts")>;
// native lib helpers
type NativeLibsKeys = keyof NativeLibs;
type NativeLibX<T extends NativeLibsKeys> = NativeLibs[T];
// get base definition or OS specific schema
type NativeLibXN<T extends NativeLibsKeys, K extends string, O extends OS | -1 = -1>
  = O extends -1 ? Conditional<NativeLibX<T>, K> : Conditional<Conditional<NativeLibX<T>, O>, K>;
// merge base definition schema with one in OS specific schema
type NativeLibXNCombined<
  T extends NativeLibsKeys, S extends string,
  // properly type things based on autogenerated CurrentRuntimeGenerics
  O extends OS = CurrentRuntimeGenerics['os'],
>
  = NativeLibXN<T, S> extends never
    ? NativeLibXN<T, S, O>
    : NativeLibXN<T, S, O> extends never
      ? NativeLibXN<T, S>
      : Overwrite<NativeLibXN<T, S>, NativeLibXN<T, S, O>>;

// consted schemas we care about
type NativeLibXBaseApi<T extends NativeLibsKeys> = NativeLibXNCombined<T, 'api'>;
type NativeLibXBaseName<T extends NativeLibsKeys> = NativeLibXNCombined<T, 'name'>;
type NativeLibXBaseConsts<T extends NativeLibsKeys> = NativeLibXNCombined<T, 'constants'>;
type NativeLibXBaseStructs<T extends NativeLibsKeys> = NativeLibXNCombined<T, 'structs'>;

// all consts are numbers for now
type NativeLibXConsts<T extends NativeLibsKeys, C = NativeLibXBaseConsts<T>> = {
  [k in keyof C]: number;
};

// map to transform fn parameter string into respective type (default is number - not there)
type ParamsTypeMap = {
  buffer: TypedArray;
  string: string;
  u32array: Uint32Array;
  bool: boolean | 1 | 0;
  void: void;
}

// make typed params optional (creates union of fixed size parameter arrays)
type ParamsTypedOptional<T extends ReadonlyArrayUnknown, O extends ReadonlyArrayUnknown> =
  T extends [...infer P extends ReadonlyArray<T[number]>, infer L extends T[number]]
    ? undefined extends L
      ? P['length'] extends keyof O
        ? O[P['length']] extends true | 1 ? P | ParamsTypedOptional<P, O> : T
        : T
      : T
    : T;
// type parameters array(s union)
type ParamsTyped<
  T, P = Conditional<T, 'parameters', -1>, O = Conditional<T, 'optional', -1>,
  PP extends ReadonlyArrayUnknown = P extends ReadonlyArrayUnknown ? P : [],
  OO extends ReadonlyArrayUnknown = O extends ReadonlyArrayUnknown ? O : [],
  PPP extends ReadonlyArrayUnknown = {
    [k in keyof PP]: (
      // ParamsTypedValue
      PP[k] extends keyof ParamsTypeMap
        ? ParamsTypeMap[PP[k]]
        : k extends number
          ? PP[k]
          : number
    ) | (
      // ParamTypedValueOptional
      k extends keyof OO
        ? OO[k] extends true | 1
          ? undefined
          : never
        : never
    )
  }
> = OO[number] extends never ? PPP : PPP | ParamsTypedOptional<PPP, OO>;

// function from definition
type NativeLibApiFn<T, PT extends ParamsTyped<T> = ParamsTyped<T>> =
  (...p: PT) => Conditional<T, 'result', -1> extends 'void' | never ? void : number;
// record of functions from definitions
type NativeLibXApi<
  T extends NativeLibsKeys,
  B extends NativeLibXBaseApi<T> = NativeLibXBaseApi<T>,
>
  = {
    [k in keyof B]: true extends Conditional<B[k], 'declare_only', -1>
      ? never
      : NativeLibApiFn<B[k]>;
  };

// [<name1>, <name2>] => <name1> | <name2>
type NativeLibXStructNames<T extends NativeLibsKeys> = Conditional<NativeLibXBaseStructs<T>, number>;
// struct names => { [struct_<name>_size]: number }
type NativeLibXStructSizes<
  T extends NativeLibsKeys,
  N extends NativeLibXStructNames<T> = NativeLibXStructNames<T>,
  S extends \`struct_\${string}_size\` = N extends string ? \`struct_\${N}_size\` : never
> = {
    [k in S]: number;
  };

// exports loaded by lo.load - { <T>: { ... } }
type NativeLibXExport<
  T extends NativeLibsKeys,
> = Record<
    T,
        (NativeLibXStructSizes<T> extends never ? {} : NativeLibXStructSizes<T>)
      & (NativeLibXConsts<T> extends never ? {} : NativeLibXConsts<T>)
      & (NativeLibXApi<T> extends never ? {} : NativeLibXApi<T>)
      // & (NativeLibXBaseName<T> extends never ? {} : { name: NativeLibXBaseName<T> })
  >;
`

const native_lib_api_types = () => `// ############ NativeLib API stuff ##############
type LIB_API_ARCH = 'x64';
type LIB_API_C_TYPE = 'u64' | 'f64' | 'u32' | 'i64' | 'f32' | 'i32' | 'u8' | 'void' | 'char';
type LIB_API_POINTER = 'pointer'
type LIB_API_BOOL = 'bool';
type LIB_API_STRING = 'string';
type LIB_API_BUFFER = 'buffer';
type LIB_API_TYPED_ARRAY = 'u32array';

type LibApiParameter = LIB_API_POINTER | LIB_API_C_TYPE | LIB_API_STRING
  | LIB_API_BUFFER | LIB_API_TYPED_ARRAY | LIB_API_BOOL;
type LibApiResult = LIB_API_POINTER | LIB_API_C_TYPE | LIB_API_BOOL;
type LibApiPointer = string; // this is sad
type LibApiOverride = { param: number, fastfield: string, slowfield: string } | number;
type LibApiItem = { nofast: boolean; declare_only: boolean; } | {
  parameters: LibApiParameter[];
  optional?: (true | false | 1 | 0 | undefined)[];
  pointers?: (LibApiPointer | void)[];
  result: LibApiResult;
  rpointer?: LibApiPointer | [LibApiPointer];
  name?: string;
  arch?: ARCH[];
  override?: (LibApiOverride | void)[];
  casts?: (string | void)[];
  jsdoc?: string;
  man?: string[] | string;
  nofast?: boolean;
  nonblocking?: boolean;
};
type LibApi = Record<string, LibApiItem>;
type LibApiTypedFn = <const T extends LibApi>(api: T) => T;


type ConstantType = Omit<LIB_API_C_TYPE, 'void' | 'char'> | number;
type LibConstants = Record<string, ConstantType>;
type LibConstsTypedFn = <const T extends LibConstants>(constnats: T) => T;

type Platform = 'mac' | 'linux';
interface LibPlatform {
  name: string;
  api: LibApi;
  constants?: LibConstants;
  structs?: string[];
  includes?: string[];
  libs?: string[];
  externs?: string[];
  include_paths?: string[];
  lib_paths?: string[];
  obj?: string[];
  preamble?: string;
}
type LibPlatformTypedFn = <const T extends Partial<LibPlatform>>(platform: T) => T;
`
